# 3.1. Issue Server-side Certificates

This chapter describes how to issue server-side certificates using OpenSSL command-line tools.

## Generate a new private key for the server

You can choose either RSA or EC keys, but you need to pay attention to the key length:

- RSA 2048
- EC 256

Here is an example using RSA:

```sh
MY_CA_L2_DIR=$RSA_CA_R1_DIR          # The directory of the intermediate CA.

NEW_CERT_DOMAIN=www.your-domain.com
NEW_SERVER_KEY_PATH=$MY_CA_L2_DIR/private/server-$NEW_CERT_DOMAIN.key.pem

openssl genrsa -rand $MY_CA_L2_DIR/.rand -out $NEW_SERVER_KEY_PATH 2048

# [Optional] Protect the private key with a password.
# openssl genrsa -rand $MY_CA_L2_DIR/.rand -aes-256-cfb -out $NEW_SERVER_KEY_PATH 2048

# Or you can use EC keys
# openssl ecparam -rand $MY_CA_L2_DIR/.rand -genkey -name prime256v1 -noout -out $NEW_SERVER_KEY_PATH

# [Optional] Protect the private EC key with a password, you can use the following command.
# openssl ec -aes-256-cfb -in $NEW_SERVER_KEY_PATH -out $NEW_SERVER_KEY_PATH
```

## Generate a certificate signing request file (`xxx.csr.pem`)

Just like the process of issuing an intermediate CA certificate, the process of issuing a server certificate is also divided into two steps.

Firstly, create a draft of the application form (`xxx.csr.cnf`), which is a **text file** describing the detailed information of the certificate to be applied for.

```sh
NEW_SERVER_CERT_REQ_PATH=$MY_CA_L2_DIR/csr/server-$NEW_CERT_DOMAIN.csr.cnf

cat > $NEW_SERVER_CERT_REQ_PATH << EOL
[ req ]
distinguished_name  = req_distinguished_name
string_mask         = utf8only
req_extensions      = req_ext
x509_extensions     = v3_req

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256
prompt              = no

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
commonName                      = $NEW_CERT_DOMAIN

[req_ext]
subjectAltName = @alt_names

[v3_req]
subjectAltName = @alt_names

[alt_names]
# IP.1 = 127.0.0.1
DNS.1 = $NEW_CERT_DOMAIN
EOL
```

> NOTE: Don't miss the `subjectAltName` in the server certificate, otherwise the browser will not recognize it.

Then use the `openssl req` command to add your certificate public key (note that this is the key of the new certificate, not the key of the CA) to the application form, and sign the application form with your certificate private key to get a new file `xxx.csr.pem`, which is a BASE64-encoded DER file.

```sh
NEW_SERVER_CERT_CSR_PATH=$MY_CA_L2_DIR/csr/server-$NEW_CERT_DOMAIN.csr.pem

openssl req \
    -config $NEW_SERVER_CERT_REQ_PATH \
    -new -sha256 \
    -key $NEW_SERVER_KEY_PATH \
    -out $NEW_SERVER_CERT_CSR_PATH
```

You can view the detailed information of the file with the following command.

```sh
openssl req \
    -in $NEW_SERVER_CERT_CSR_PATH \
    -noout \
    -text
```

## Sign the certificate

Now, everything is ready, let's sign the certificate, with an intermediate CA:

```sh
NEW_SERVER_CERT_PATH=$MY_CA_L2_DIR/issued_certs/server-$NEW_CERT_DOMAIN.cert.pem

openssl ca \
    -config $MY_CA_L2_DIR/ca.cnf \
    -extensions server_cert \
    -days 180 \
    -notext \
    -md sha256 \
    -batch \
    -in $NEW_SERVER_CERT_CSR_PATH \
    -out $NEW_SERVER_CERT_PATH
```

Here is the explanation of the command:

- Option `-config $MY_CA_L2_DIR/ca.cnf`

    This option specifies the configuration file of the CA, which is described in the previous chapter.

- Option `-batch`

    This option indicates that the batch automation mode is used, and the information is read directly from the CA configuration and command-line parameters.
    So no interactive input is required.

- Option `-md sha256`

    Specifies the hash algorithm to use when signing the certificate.
    If omitted, the algorithm specified by `default_md` in the CA configuration file is used.

- Option `-days`

    Specifies the validity period of the certificate (from the system time when it is signed), in days.
    If omitted, the duration specified by `default_days` in the CA configuration file is used.

    > If you need to generate a certificate for a specific time (such as an expired certificate for some test scenarios), you can replace the parameter `-days 180` with `-startdate 220101000000Z -enddate 220301000000Z`.
    > Where,
    > - `-startdate` indicates the start time of the certificate validity period, in the format `YYMMDDhhmmssZ`, where the year, month, day, hour, minute, and second are represented by 2 digits each, and the Z at the end indicates the use of the UTC time zone.
    > - `-enddate` indicates the end time of the certificate validity period, in the same format as above.

And then, check the detailed information of the generated certificate with this command.

```sh
openssl x509 -noout -text -in $NEW_SERVER_CERT_PATH
```

You can check whether the intermediate CA certificate can be used to verify the server certificate with the following command.

```sh
openssl verify -CAfile $MY_CA_L2_DIR/ca.fullchain.pem $NEW_SERVER_CERT_PATH
```

## Generate the full chain of the server certificate

In the previous command, a chain of certificates is used, because a full chain is required to verify the server certificate.

So, you need to generate a full chain of the server certificate.

```sh
NEW_SERVER_FULLCHAIN_PATH=$MY_CA_L2_DIR/issued_certs/server-$NEW_CERT_DOMAIN.fullchain.pem

cat > $NEW_SERVER_FULLCHAIN_PATH << EOL
$(cat $NEW_SERVER_CERT_PATH)

$(cat $MY_CA_L2_DIR/ca.fullchain.pem)
EOL
```

Then, verify the certificate chain with the following command.

```sh
openssl verify -CAfile $MY_CA_L2_DIR/ca.fullchain.pem $NEW_SERVER_FULLCHAIN_PATH
```

Now, a server certificate has been successfully issued, and you can use it to configure your server.
