# 3.2. Issue Client-side Certificates

This chapter describes how to issue client-side certificates using OpenSSL command-line tools.

## Generate a new private key for the client

You can choose either RSA or EC keys, but you need to pay attention to the key length:

- RSA 2048
- EC 256

Here is an example using RSA:

```sh
MY_CA_L2_DIR=$RSA_CA_R1_DIR          # The directory of the intermediate CA.

NEW_CERT_NAME=angus@litert.org
NEW_CLIENT_KEY_PATH=$MY_CA_L2_DIR/private/client-$NEW_CERT_NAME.key.pem

openssl genrsa -rand $MY_CA_L2_DIR/.rand -aes-256-cfb -out $NEW_CLIENT_KEY_PATH 2048

# [Optional] Protect the private key with a password.
# openssl genrsa -rand $MY_CA_L2_DIR/.rand -aes-256-cfb -out $NEW_CLIENT_KEY_PATH 2048

# Or you can use EC keys
# openssl ecparam -rand $MY_CA_L2_DIR/.rand -genkey -name prime256v1 -noout -out $NEW_CLIENT_KEY_PATH

# [Optional] If you want to protect the private EC key with a password, you can use the following command.
# openssl ec -aes-256-cfb -in $NEW_CLIENT_KEY_PATH -out $NEW_CLIENT_KEY_PATH
```

## Generate a certificate signing request file (`xxx.csr.pem`)

Just like the process of issuing an intermediate CA certificate, the process of issuing a client certificate is also divided into two steps.

Firstly, create a draft of the application form (`xxx.csr.cnf`), which is a **text file** describing the detailed information of the certificate to be applied for.

```sh
NEW_CLIENT_CERT_REQ_PATH=$MY_CA_L2_DIR/csr/client-$NEW_CERT_NAME.csr.cnf

cat > $NEW_CLIENT_CERT_REQ_PATH << EOL
[ req ]
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256
prompt              = no

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
commonName                      = $NEW_CERT_NAME
EOL
```

Then use the `openssl req` command to add your certificate public key (note that this is the key of the new certificate, not the key of the CA) to the application form, and sign the application form with your certificate private key to get a new file `xxx.csr.pem`, which is a BASE64-encoded DER file.

```sh
NEW_CLIENT_CERT_CSR_PATH=$MY_CA_L2_DIR/csr/client-$NEW_CERT_NAME.csr.pem

openssl req \
    -config $NEW_CLIENT_CERT_REQ_PATH \
    -new -sha256 \
    -key $NEW_CLIENT_KEY_PATH \
    -out $NEW_CLIENT_CERT_CSR_PATH
```

You can view the detailed information of the file with the following command.

```sh
openssl req \
    -in $NEW_CLIENT_CERT_CSR_PATH \
    -noout \
    -text
```

## Sign the certificate

Now, everything is ready, let's sign the certificate, with an intermediate CA:

```sh
NEW_CLIENT_CERT_PATH=$MY_CA_L2_DIR/issued_certs/client-$NEW_CERT_NAME.cert.pem

openssl ca \
    -config $MY_CA_L2_DIR/ca.cnf \
    -extensions client_cert \
    -days 180 \
    -notext \
    -md sha256 \
    -batch \
    -in $NEW_CLIENT_CERT_CSR_PATH \
    -out $NEW_CLIENT_CERT_PATH
```

Here is the explanation of the command:

- Option `-config $MY_CA_L2_DIR/ca.cnf`

    This option specifies the configuration file of the CA, which is described in the previous chapter.

- Option `-batch`

    This option indicates that the batch automation mode is used, and the information is read directly from the CA configuration and command-line parameters.
    So no interactive input is required.

- Option `-md sha256`

    Specifies the hash algorithm to use when signing the certificate.
    If omitted, the algorithm specified by `default_md` in the CA configuration file is used.

- Option `-days`

    Specifies the validity period of the certificate (from the system time when it is signed), in days.
    If omitted, the duration specified by `default_days` in the CA configuration file is used.

    > If you need to generate a certificate for a specific time (such as an expired certificate for some test scenarios), you can replace the parameter `-days 180` with `-startdate 220101000000Z -enddate 220301000000Z`.
    > Where,
    > - `-startdate` indicates the start time of the certificate validity period, in the format `YYMMDDhhmmssZ`, where the year, month, day, hour, minute, and second are represented by 2 digits each, and the Z at the end indicates the use of the UTC time zone.
    > - `-enddate` indicates the end time of the certificate validity period, in the same format as above.

And then, check the detailed information of the generated certificate with this command.

```sh
openssl x509 -noout -text -in $NEW_CLIENT_CERT_PATH
```

You can check whether the intermediate CA certificate can be used to verify the client certificate with the following command.

```sh
openssl verify -CAfile $MY_CA_L2_DIR/ca.fullchain.pem $NEW_CLIENT_CERT_PATH
```

## Generate the full chain of the client certificate

In the previous command, a chain of certificates is used, because a full chain is required to verify the client certificate.

So, you need to generate a full chain of the client certificate.

```sh
NEW_CLIENT_FULLCHAIN_PATH=$MY_CA_L2_DIR/issued_certs/client-$NEW_CERT_NAME.fullchain.pem

cat > $NEW_CLIENT_FULLCHAIN_PATH << EOL
$(cat $NEW_CLIENT_CERT_PATH)

$(cat $MY_CA_L2_DIR/ca.fullchain.pem)
EOL
```

Then, verify the certificate chain with the following command.

```sh
openssl verify -CAfile $MY_CA_L2_DIR/ca.fullchain.pem $NEW_CLIENT_FULLCHAIN_PATH
```

Now, a client certificate has been successfully issued, and you can use it to configure your client.
